<?php

namespace App\Http\Controllers;

use App\Model\BombPackage;
use App\Model\BoxMatches;
use App\Service\BombsPayment;
use Exception;
use Illuminate\Http\Request;
use App\Model\Card;
use App\Model\User;
use App\Notifications\PaymentNotification;
use App\Model\SlackPayment;
use App\Model\Tournament;
use Illuminate\Support\Facades\Auth;

class BombController extends Controller
{
    //
    /**
     * @OA\Post(
     *     path="/api/payment/bomb-purchase-token",
     *     tags={"Bomb-Purchase"},
     * * @OA\Parameter(
     *     name="name",
     *     in="query",
     *     description="Name of the card holder",
     *     required=true,
     * ),
     * @OA\Parameter(
     *     name="tokenId",
     *     in="query",
     *     description="Card tokenId generated by Stripe Card Element",
     *     required=true,
     * ),
     * @OA\Parameter(
     *     name="saveCard",
     *     in="query",
     *     description="(1 or 0) Save card information or not",
     *     required=true,
     * ),
     * @OA\Parameter(
     *     name="packageID",
     *     in="query",
     *     description="ID of bombs package being purchased",
     *     required=true,
     * ),
     *     @OA\Response(response="200", description="Purchase bombs and save card (optional) using new card"),
     *     security={
     *         {"query_token": {}}
     *     }
     * )
     */

    public function bombPurchaseWithToken(request $request)
    {
        $this->validate(
            $request->all(),
            [
                'tokenId' => ['required'],
                'name' => ['required'],
                'saveCard' => ['required'],
                'packageID' => ['required', 'numeric'],
            ]
        );

        $user = Auth::user();

        $cardDetails = [];
        $bombPackage = BombPackage::getPackage($request->packageID);
        $existingCard = Card::getAllPaymentMethod($user->id);

        if (!$bombPackage) {
            return $this->resourceNotFound('Package not found');
        }

        $paymentMethod = Card::createPaymentMethod($request->tokenId);

        if ($paymentMethod['error']) {
            return $this->internalErrorApiResponse([], $paymentMethod['error'], 400);
        }

        $stripeReturn = null;
        if ($request->saveCard) {
            $stripe_id = $user->stripe_id;

            if (!$stripe_id) {
                return $this->internalErrorApiResponse([], 'No Stripe Customer Created yet', 400);
            }

            $ret = Card::attachPaymentMethod($paymentMethod, $stripe_id);
            if ($ret) {
                return $this->internalErrorApiResponse([], $ret, 400);
            }

            $cardDetail = Card::addPaymentMethodDB($paymentMethod, $user->id, $request->name);
            if ($existingCard->isEmpty()) {
                $ret = Card::makeDefaultMethodForUser($stripe_id, $cardDetail->stripe_payment_method);
                if (!$ret) {
                    $this->internalErrorApiResponse([], 'Some error occured with stripe payment.', 400);
                }
                if ($ret['error']) {
                    $this->internalErrorApiResponse([], $ret['error'], 400);
                }
            }
            $cardDetails['last_four'] = $cardDetail->last_four;
            $cardDetails['brand'] = $cardDetail->brand;
            $stripe = new \Stripe\StripeClient(
                config('services.stripe.secret')
            );


            $error = 0;
            try {
                // Use Stripe's library to make requests...
                $stripeReturn = $stripe->paymentIntents->create(
                    [
                        'amount' => $bombPackage->price * 100,
                        'currency' => 'eur',
                        'payment_method_types' => ['card'],
                        'payment_method' => $paymentMethod->id,
                        'customer' => $stripe_id,
                    ]
                );

                $successStatus = $stripe->paymentIntents->confirm(
                    $stripeReturn->id,
                    []
                );
            } catch (\Stripe\Exception\CardException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\RateLimitException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\InvalidRequestException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\AuthenticationException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\ApiConnectionException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\ApiErrorException $e) {
                $error = $e->getError()->message;
            } catch (Exception $e) {
                $error = $e->getError()->message;
            }
            if ($error) {
                return $this->internalErrorApiResponse([], $error, 400);
            }
        } else {
            $cardDetails['last_four'] = $paymentMethod->card->last4;
            $cardDetails['brand'] = $paymentMethod->card->brand;;
            $stripe = new \Stripe\StripeClient(
                config('services.stripe.secret')
            );

            $error = 0;
            try {
                // Use Stripe's library to make requests...
                $stripeReturn = $stripe->paymentIntents->create(
                    [
                        'amount' => $bombPackage->price * 100,
                        'currency' => 'eur',
                        'payment_method_types' => ['card'],
                        'payment_method' => $paymentMethod->id,
                    ]
                );

                $successStatus = $stripe->paymentIntents->confirm(
                    $stripeReturn->id,
                    []
                );
            } catch (\Stripe\Exception\CardException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\RateLimitException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\InvalidRequestException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\AuthenticationException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\ApiConnectionException $e) {
                $error = $e->getError()->message;
            } catch (\Stripe\Exception\ApiErrorException $e) {
                $error = $e->getError()->message;
            } catch (Exception $e) {
                $error = $e->getError()->message;
            }

            if ($error) {
                return $this->internalErrorApiResponse([], $error, 400);
            }
        }

        if ($successStatus->status != 'succeeded') {
            return $this->internalErrorApiResponse([], 'Some error occured in the transaction', 400);
        }
        try {
            BombsPayment::buyBombsTournament(
                $user->id,
                $bombPackage->price,
                $bombPackage->bombs,
                0,
                $bombPackage->free_bombs,
                json_encode($successStatus)
            );

            \Notification::send(
                new SlackPayment(),
                new PaymentNotification(
                    $user,
                    $cardDetails,
                    $bombPackage
                )
            );

            return $this->successApiResponse(auth()->user()->makeVisible('all_bombs'));
        } catch (Exception $e) {
            return $this->internalErrorApiResponse($e, 'Some error occurred');
        }
    }


    /**
     * @OA\Post(
     *     path="/api/payment/bomb-purchase-payment-method/{id}",
     *     tags={"Bomb-Purchase"},
     * @OA\Parameter(
     *     name="id",
     *     in="path",
     *     description="User ID of Customer",
     *     required=true,
     * ),
     * @OA\Parameter(
     *     name="packageID",
     *     in="query",
     *     description="ID of bombs package being purchased",
     *     required=true,
     * ),
     * @OA\Parameter(
     *     name="cardID",
     *     in="query",
     *     description="payment method id from DB",
     *     required=true,
     * ),
     *     @OA\Response(response="200", description="Purchase bombs and save card (optional) using existing cards"),
     * security={
     *         {"query_token": {}}
     *     }
     * )
     */

    public function bombPurchaseWithPaymentMethod(request $request, $id)
    {
        $this->validate(
            $request->all(),
            [
                'cardID' => ['required'],
                'packageID' => ['required', 'numeric'],
            ]
        );
        $user = Auth::user();
        $id = $user->id;
        $bombPackage = BombPackage::getPackage($request->packageID);
        if (!$bombPackage) {
            return response()->json(
                [
                    'message' => 'Package not found'
                ],
                400
            );
        }
        $stripe_id = User::getUserStripeId($id);
        if (!$stripe_id) {
            return response()->json(
                [
                    'message' => 'No Stripe Customer Created yet'
                ],
                400
            );
        }
        $paymentMethod = Card::getPaymentMethod($request->cardID);
        if (!$paymentMethod) {
            return response()->json(
                [
                    'message' => 'Card not found'
                ],
                400
            );
        }

        $cardDetails['last_four'] = $paymentMethod->last_four;
        $cardDetails['brand'] = $paymentMethod->brand;


        $stripe = new \Stripe\StripeClient(
            config('services.stripe.secret')
        );
        $stripeReturn = null;
        $error = 0;

        try {
            // Use Stripe's library to make requests...
            $stripeReturn = $stripe->paymentIntents->create(
                [
                    'amount' => $bombPackage->price * 100,
                    'currency' => 'eur',
                    'payment_method_types' => ['card'],
                    'payment_method' => $paymentMethod->stripe_payment_method,
                    'customer' => $stripe_id,
                ]
            );
            $successStatus = $stripe->paymentIntents->confirm(
                $stripeReturn->id,
                []
            );
        } catch (\Stripe\Exception\CardException $e) {
            $error = $e->getError()->message;
        } catch (\Stripe\Exception\RateLimitException $e) {
            $error = $e->getError()->message;
        } catch (\Stripe\Exception\InvalidRequestException $e) {
            $error = $e->getError()->message;
        } catch (\Stripe\Exception\AuthenticationException $e) {
            $error = $e->getError()->message;
        } catch (\Stripe\Exception\ApiConnectionException $e) {
            $error = $e->getError()->message;
        } catch (\Stripe\Exception\ApiErrorException $e) {
            $error = $e->getError()->message;
        } catch (Exception $e) {
            $error = $e->getError()->message;
        }
        if ($error) {
            return response()->json(
                [
                    'message' => $error
                ],
                400
            );
        }



        if($successStatus->status != 'succeeded')
        {
            return response()->json(
                [
                    'message' => 'Some error occurred in the transaction'
                ],
                400
            );
        }

        try {
            BombsPayment::buyBombsTournament(
                $id,
                $bombPackage->price,
                $bombPackage->bombs,
                0,
                $bombPackage->free_bombs,
                json_encode($successStatus)
            );

            \Notification::send(
                new SlackPayment(),
                new PaymentNotification(
                    User::find($id),
                    $cardDetails,
                    $bombPackage
                )
            );

            return $this->successApiResponse(User::find($id));

        } catch (Exception $e) {
            return $this->internalErrorApiResponse('Some error occured');
        }
    }


    /**
     * @OA\Get(
     *     path="/api/payment/get-user-bombs/{id}",
     *     tags={"Bomb-Purchase"},
     *   @OA\Parameter(
     *     name="id",
     *     in="path",
     *     description="User ID of Customer",
     *     required=true,
     * ),
     *     @OA\Response(response="200", description="Get Users bombs"),
     * security={
     *         {"query_token": {}}
     *     }
     * )
     */

    public function getUserBombs($id)
    {
        $user = Auth::user();
        $id = $user->id;
        $data['bombs'] = BombsPayment::getUserBombs($user);
        return response()->json($data);
    }

    /**
     * @OA\Get(
     *     path="/api/payment/get-bombs-withdrawable/{id}",
     *     tags={"Bomb-Purchase"},
     *   @OA\Parameter(
     *     name="id",
     *     in="path",
     *     description="User ID of Customer",
     *     required=true,
     * ),
     *     @OA\Response(response="200", description="Get Users bombs that can be withdrawn  "),
     * security={
     *         {"query_token": {}}
     *     }
     * )
     */

    public function getUsersWithdrawableBombs($id)
    {
        $user = Auth::user();
        $data['bombs'] = BombsPayment::getUserBombs($user);
        $userBombsFree = $user->bomb->bombs_free;
        $data['bombs'] = $data['bombs'] - $userBombsFree;
        return response()->json(['withdrawable bombs' => $data]);
    }

    public function withdrawBombs(request $request, $id)
    {
        $this->validate(
            $request->all(),
            [
                'bombs' => ['required', 'numeric'],
            ]
        );

        $bombs = User::getwithdrawableBombs($id);
        if ($request->bombs > $bombs) {
            return response()->json(
                [
                    'message' => 'The Number of bombs being withdrawn are more than the bombs available for withdraw.'
                ],
                400
            );
        }
    }

}
